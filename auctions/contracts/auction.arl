archetype auction(
    owner: address,
    fee_receiver: address,
    protocol_fee: nat,
    royalties_provider: address
)
with metadata ""

constant MISSING_ASSET_ID: string = "MISSING_ASSET_ID"
constant MISSING_ASSET_CONTRACT: string = "MISSING_ASSET_CONTRACT"
constant MISSING_AUCTION_STORAGE_CONTRACT: string = "MISSING_AUCTION_STORAGE_CONTRACT"
constant MISSING_AUCTION_CUSTODY_CONTRACT: string = "MISSING_AUCTION_CUSTODY_CONTRACT"
constant AUCTION_ALREADY_EXISTS: string = "AUCTION_ALREADY_EXISTS"
constant AUCTION_NOT_IN_PROGRESS: string = "AUTION_NOT_IN_PROGRESS"
constant AUCTION_FINISHED: string = "AUTION_FINISHED"
constant AUCTION_START_DATE_IN_THE_PAST: string = "AUCTION_START_DATE_IN_THE_PAST"
constant MISSING_AUCTION: string = "MISSING_AUCTION"
constant AUCTION_BID_TOO_LOW: string = "AUCTION_BID_TOO_LOW"
constant AUCTION_BID_ALREADY_EXISTS: string = "AUCTION_BID_ALREADY_EXISTS"
constant AUCTION_BID_AMOUNT_MISMATCH: string = "AUCTION_BID_AMOUNT_MISMATCH"

//----------------------------------------------------------------------------
// Owner role transfer
//----------------------------------------------------------------------------

variable owner_candidate : option<address> = none

entry declare_ownership(candidate : address) {
  called by owner
  effect {
    owner_candidate := some(candidate);
  }
}

entry claim_ownership() {
  called by opt_get(owner_candidate)
  effect {
    owner := opt_get(owner_candidate);
    owner_candidate := none
  }
}

//----------------------------------------------------------------------------
// Auction variables
//----------------------------------------------------------------------------
variable extension_duration : duration = 15m
variable max_duration : duration = 1000d
variable auction_storage: option<address> = none

//----------------------------------------------------------------------------
// Admin
//----------------------------------------------------------------------------
entry set_auction_storage_contract(sacs_contract : option<address>) {
  called by owner
  effect {
    auction_storage := sacs_contract;
  }
}

entry set_extension_duration(sed : duration) {
  called by owner
  effect {
    extension_duration := sed;
  }
}

entry set_max_duration(smd : duration) {
  called by owner
  effect {
    max_duration := smd;
  }
}

entry set_protocol_fee(spf : nat) {
  called by owner
  effect {
    protocol_fee := spf;
  }
}

entry set_fee_receiver(sfr : address) {
  called by owner
  effect {
    fee_receiver := sfr;
  }
}

entry set_royalties_provider(srp : address) {
  called by owner
  effect {
    royalties_provider := srp;
  }
}

//----------------------------------------------------------------------------
// Types
//----------------------------------------------------------------------------

enum fa2_class =
| Fungible
| NonFungible
| Unknown

enum enum_asset_class =
| XTZ
| FA_1_2
| FA_2<fa2_class>
| FA_2_LAZY<fa2_class>
| OTHER<bytes>

record rec_asset_type {
  asset_class : enum_asset_class;
}

record %asset {
  asset_type : rec_asset_type;
  asset_contract : option<address>;
  asset_id: option<nat>;
}

record transfer_param {
  destination_address: address;
  token_id: nat;
  token_amount: nat
} as ((%to, (token_id, amount)))

record part {
  part_account : address;
  part_value   : nat;
}

record bid {
  bid_payouts : list<part>;
  bid_origin_fees : list<part>;
  bid_amount : nat;
  bid_bidder: address;
}

record auction_record {
  auction_sell_asset : %asset;
  auction_sell_asset_amount: nat;
  auction_buy_asset : %asset;
  auction_last_bid: option<bid>;
  auction_seller: address;
  auction_start_time: date;
  auction_end_time: date;
  auction_minimal_price: nat;
  auction_buy_out_price: nat;
  auction_minimal_step: nat;
  auction_protocol_fee: nat;
  auction_payouts : list<part>;
  auction_origin_fees : list<part>;
}

record auction_args {
  auction_args_sell_asset : %asset;
  auction_args_sell_asset_amount: nat;
  auction_args_buy_asset : %asset;
  auction_args_seller: address;
  auction_args_start_time: option<date>;
  auction_args_duration: duration;
  auction_args_minimal_price: nat;
  auction_args_buy_out_price: nat;
  auction_args_minimal_step: nat;
  auction_args_payouts : list<part>;
  auction_args_origin_fees : list<part>;
}

//----------------------------------------------------------------------------
// Auction entries
//----------------------------------------------------------------------------

entry start_auction(
    sa_auction: auction_args
) {
    require{
        r_sa0: sa_auction.auction_args_sell_asset.asset_type.asset_class = FA_2(NonFungible);
        r_sa1: sa_auction.auction_args_buy_asset.asset_type.asset_class = FA_2(Fungible)
            or
            sa_auction.auction_args_buy_asset.asset_type.asset_class = FA_1_2
            or
            sa_auction.auction_args_buy_asset.asset_type.asset_class = XTZ;
        r_sa2: sa_auction.auction_args_duration > extension_duration;
        r_sa3: sa_auction.auction_args_duration < max_duration;
        r_sa4: sa_auction.auction_args_buy_out_price > sa_auction.auction_args_minimal_price;
        r_sa5: sa_auction.auction_args_minimal_price > 0;
        r_sa6: sa_auction.auction_args_minimal_step > 0;
        r_sa7: sa_auction.auction_args_seller = caller;
    }
    effect {
        var auction_storage_contract = require_some(auction_storage, MISSING_AUCTION_STORAGE_CONTRACT);
        var auction_asset_id = require_some(sa_auction.auction_args_sell_asset.asset_id, MISSING_ASSET_ID);
        var auction_asset_contract = require_some(sa_auction.auction_args_sell_asset.asset_contract, MISSING_ASSET_CONTRACT);

        dorequire(auction_exists(auction_asset_contract, auction_asset_id) = false, AUCTION_ALREADY_EXISTS);

        var start_time: date = now;
        var end_time: date = now;
        if (sa_auction.auction_args_start_time <> none<date>) then (
            start_time := opt_get(sa_auction.auction_args_start_time);
            dorequire(start_time >= now, AUCTION_START_DATE_IN_THE_PAST);
            end_time := start_time + sa_auction.auction_args_duration;
        ) else (
            start_time := now;
            end_time := now + sa_auction.auction_args_duration;
        );

        var storage_auction: auction_record = {
            auction_sell_asset = sa_auction.auction_args_sell_asset;
            auction_sell_asset_amount = sa_auction.auction_args_sell_asset_amount;
            auction_buy_asset = sa_auction.auction_args_buy_asset;
            auction_last_bid = none;
            auction_seller = sa_auction.auction_args_seller;
            auction_start_time = start_time;
            auction_end_time = end_time;
            auction_minimal_price = sa_auction.auction_args_minimal_price;
            auction_buy_out_price = sa_auction.auction_args_buy_out_price;
            auction_minimal_step = sa_auction.auction_args_minimal_step;
            auction_protocol_fee = protocol_fee;
            auction_payouts = sa_auction.auction_args_payouts;
            auction_origin_fees = sa_auction.auction_args_origin_fees
        };

        transfer 0tz to auction_storage_contract call set_auction<auction_record>(storage_auction);
        transfer 0tz to auction_asset_contract call %transfer<list<address * list<transfer_param>>>(
            [
                (
                    sa_auction.auction_args_seller,
                    [
                        {
                            destination_address = auction_storage_contract;
                            token_id = auction_asset_id;
                            token_amount = sa_auction.auction_args_sell_asset_amount
                        }
                    ]
                )
            ]
        );
    }
}

entry put_bid(pb_asset_contract: address, pb_asset_id: nat, pb_bid: bid){
  require{
        r_pb0: pb_bid.bid_amount > 0;
        r_pb1: pb_bid.bid_bidder = caller;
    }
    effect {
      var auction = require_some(get_auction_record(pb_asset_contract, pb_asset_id), MISSING_AUCTION);
      dorequire(auction.auction_start_time < now, AUCTION_NOT_IN_PROGRESS);
      dorequire(auction.auction_end_time > now, AUCTION_FINISHED);

      if (auction.auction_buy_out_price > 0 and auction.auction_buy_out_price < pb_bid.bid_amount) then (
        if(auction.auction_buy_asset.asset_type.asset_class = XTZ) then (
          dorequire(transferred = (pb_bid.bid_amount * 1mtz), AUCTION_BID_AMOUNT_MISMATCH);
        );
        transfer 0tz to require_some(auction_storage, MISSING_AUCTION_STORAGE_CONTRACT) call update_bid_for_auction<address * nat * bid>((pb_asset_contract, pb_asset_id, pb_bid))
      );

      if(isnone(auction.auction_last_bid)) then (
        dorequire(auction.auction_minimal_price <= pb_bid.bid_amount, AUCTION_BID_TOO_LOW);
        dorequire(auction.auction_minimal_step <= pb_bid.bid_amount, AUCTION_BID_TOO_LOW);
      ) else (
        dorequire(opt_get(auction.auction_last_bid).bid_amount < pb_bid.bid_amount, AUCTION_BID_TOO_LOW);
        dorequire(auction.auction_minimal_step <= pb_bid.bid_amount - opt_get(auction.auction_last_bid).bid_amount, AUCTION_BID_TOO_LOW);
        dorequire(opt_get(auction.auction_last_bid).bid_bidder <> pb_bid.bid_bidder, AUCTION_BID_ALREADY_EXISTS);
      );
    }
}

function auction_exists(ae_asset_contract: address, ae_asset_id: nat) : bool {
    return match callview<bool>(
        require_some(auction_storage, MISSING_AUCTION_STORAGE_CONTRACT),
        "auction_exists",
        (
            ae_asset_contract,
            ae_asset_id
        )
    )
    with
        | some(v) -> v
        | none -> false
    end
}

function get_auction_record(gar_asset_contract: address, gar_asset_id: nat) : option<auction_record> {
    return match callview<auction_record>(
        require_some(auction_storage, MISSING_AUCTION_STORAGE_CONTRACT),
        "get_auction",
        (
            gar_asset_contract,
            gar_asset_id
        )
    )
    with
        | some(v) -> some(v)
        | none -> none<auction_record>
    end
}

function do_fa2_transfer(dt2_contract: address, dt2_token_id: nat, dt2_amount: nat, dt2_origin: address, dt2_destination: address ) {
  transfer 0tz to dt2_contract call %transfer<list<address * list<transfer_param>>>(
            [
                (
                    dt2_origin,
                    [
                        {
                            destination_address = dt2_destination;
                            token_id = dt2_token_id;
                            token_amount = dt2_amount
                        }
                    ]
                )
            ]
        )
}

entry manage_transfer(mt_asset_class: enum_asset_class, mt_asset_contract: option<address>, mt_asset_id: option<nat>, mt_amount: nat, mt_origin: address, mt_destination: address){
  called by selfaddress
  effect {
    var res = 0;
    match mt_asset_class with
    | FA_2(fa2t)  -> (
      dorequire(issome(mt_asset_contract), MISSING_ASSET_CONTRACT);
      dorequire(issome(mt_asset_id), MISSING_ASSET_CONTRACT);

      transfer 0tz to opt_get(mt_asset_contract) call %transfer<list<address * list<transfer_param>>>(
            [
                (
                    mt_origin,
                    [
                        {
                            destination_address = mt_destination;
                            token_id = opt_get(mt_asset_id);
                            token_amount = mt_amount
                        }
                    ]
                )
            ]
        )
    )
    | FA_1_2 -> (
      dorequire(issome(mt_asset_contract), MISSING_ASSET_CONTRACT);
      transfer 0tz to opt_get(mt_asset_contract) call %transfer<address * address * nat>((mt_origin, mt_destination, mt_amount))
      )
    | XTZ -> transfer (mt_amount * 1mtz) to mt_destination
    | _ -> ()
    end;
  }
}


function do_fa12_transfer(dt12_contract: address, dt12_amount: nat, dt12_origin: address, dt12_destination: address ) {
  transfer 0tz to dt12_contract call %transfer<address * address * nat>((dt12_origin, dt12_destination, dt12_amount))
}

function update_bid_for_auction(ubfa_asset_contract: address, ubfa_asset_id: nat, ubfa_bid: bid) {
  transfer 0tz to require_some(auction_storage, MISSING_AUCTION_STORAGE_CONTRACT) call update_bid_for_auction<address * nat * bid>((ubfa_asset_contract, ubfa_asset_id, ubfa_bid))
}