archetype auction_storage(
  owner: address
)
with metadata ""

constant MISSING_AUCTION_CONTRACT: string = "MISSING_AUCTION_CONTRACT"
constant MISSING_ASSET_ID: string = "MISSING_ASSET_ID"
constant MISSING_ASSET_CONTRACT: string = "MISSING_ASSET_CONTRACT"
constant MISSING_AUCTION: string = "MISSING_AUCTION"

enum fa2_class =
| Fungible
| NonFungible
| Unknown

enum enum_asset_class =
| XTZ
| FA_1_2
| FA_2<fa2_class>
| FA_2_LAZY<fa2_class>
| OTHER<bytes>

record rec_asset_type {
  asset_class : enum_asset_class;
}

record %asset {
  asset_type : rec_asset_type;
  asset_contract : option<address>;
  asset_id: option<nat>;
}

record part {
  part_account : address;
  part_value   : nat;
}

record operator_param {
  opp_owner    : address;
  opp_operator : address;
  opp_token_id : nat
} as ((owner, (operator, token_id)))

//----------------------------------------------------------------------------
// Owner role transfer
//----------------------------------------------------------------------------

variable owner_candidate : option<address> = none

entry declare_ownership(candidate : address) {
  called by owner
  effect {
    owner_candidate := some(candidate);
  }
}

entry claim_ownership() {
  called by opt_get(owner_candidate)
  effect {
    owner := opt_get(owner_candidate);
    owner_candidate := none
  }
}

//----------------------------------------------------------------------------
// Admin
//----------------------------------------------------------------------------
entry set_auction_contract(sac_contract : address) {
  called by owner
  effect {
    auction_contract := some(sac_contract);
    authorizations.clear();
  }
}

entry clear_authorizations() {
  called by owner
  effect {
    authorizations.clear();
  }
}

//----------------------------------------------------------------------------
// Auction
//----------------------------------------------------------------------------
variable auction_contract : option<address> = none
variable max_transferrable_fa12_amount : nat = 10000000000000000000

record bid {
  bid_payouts : list<part>;
  bid_origin_fees : list<part>;
  bid_amount : nat;
  bid_bidder: address;
}

record auction_record {
  auction_sell_asset : %asset;
  auction_sell_asset_amount: nat;
  auction_buy_asset : %asset;
  auction_last_bid: option<bid>;
  auction_seller: address;
  auction_start_time: date;
  auction_end_time: date;
  auction_minimal_price: nat;
  auction_buy_out_price: nat;
  auction_minimal_step: nat;
  auction_protocol_fee: nat;
  auction_payouts : list<part>;
  auction_origin_fees : list<part>;
}


asset auctions identified by auction_asset auction_asset_id to big_map {
  auction_asset : address;
  auction_asset_id: nat;
  auction_data : auction_record;
}

asset authorizations identified by authorization_contract authorization_contract_token_id to big_map {
  authorization_contract : address;
  authorization_contract_token_id: option<nat>;
}

entry set_auction(sa_auction : auction_record) {
  called by require_some(auction_contract, MISSING_AUCTION_CONTRACT)
  require {
      r0: issome(auction_contract);
      r1: issome(sa_auction.auction_sell_asset.asset_contract);
      r2: issome(sa_auction.auction_sell_asset.asset_id)
  }
  effect {
    var sa_auction_contract = opt_get(auction_contract);
    var sa_asset_id = opt_get(sa_auction.auction_sell_asset.asset_id);
    var sa_asset_contract = opt_get(sa_auction.auction_sell_asset.asset_contract);
    var sa_buy_asset = sa_auction.auction_buy_asset;

    auctions.add({auction_asset = sa_asset_contract; auction_asset_id = sa_asset_id; auction_data = sa_auction});
    //Since we only create auctions for NFTs (FA2), we need to declare the auction contract as operator for this NFT to allow
    //it to transfer from custody
    if(not authorizations.contains((sa_asset_contract, sa_auction.auction_sell_asset.asset_id))) then (
      authorizations.add({authorization_contract = sa_asset_contract; authorization_contract_token_id = sa_auction.auction_sell_asset.asset_id});
      transfer 0tz to sa_asset_contract call update_operators<list<or<operator_param, operator_param>>>(
      [
          left<operator_param>({ opp_owner = selfaddress; opp_operator = sa_auction_contract; opp_token_id = sa_asset_id})
      ]
    );
    );


    //If the asset is a FA2, we need to declare the auction contract as operator for the buy asset to allow it to transfer
    //from custody
    //It is more tricky for FA12 as it needs to be approved for a decreasing amount transfer
    if(issome(sa_buy_asset.asset_contract) and issome(sa_buy_asset.asset_id)) then (
      if(not authorizations.contains((sa_asset_contract, sa_auction.auction_sell_asset.asset_id))) then (
        var buy_asset_contract = opt_get(sa_buy_asset.asset_contract);
        var buy_asset_id = opt_get(sa_buy_asset.asset_id);
        authorizations.add({authorization_contract = buy_asset_contract; authorization_contract_token_id = sa_buy_asset.asset_id});
        transfer 0tz to buy_asset_contract call update_operators<list<or<operator_param, operator_param>>>(
          [
              left<operator_param>({ opp_owner = selfaddress; opp_operator = sa_auction_contract; opp_token_id = opt_get(sa_buy_asset.asset_id)})
          ]
        );
      )
    ) else if(issome(sa_buy_asset.asset_contract) and isnone(sa_buy_asset.asset_id)) then (
      if(not authorizations.contains((sa_asset_contract, sa_auction.auction_sell_asset.asset_id))) then (
        //TODO
        //Attention point: we will need to reset the allowance on regular basis because it will decrease for every tx
        var buy_asset_contract = opt_get(sa_buy_asset.asset_contract);
        authorizations.add({authorization_contract = buy_asset_contract; authorization_contract_token_id = sa_buy_asset.asset_id});
        transfer 0tz to opt_get(sa_buy_asset.asset_contract) call approve<address * nat>((sa_auction_contract, max_transferrable_fa12_amount));
      )
    );

  }
}

entry update_bid_for_auction(ubfa_asset_contract: address, ubfa_asset_id: nat, ubfa_bid: bid) {
  called by require_some(auction_contract, MISSING_AUCTION_CONTRACT)
  effect {
    dorequire(auctions.contains((ubfa_asset_contract, ubfa_asset_id)), MISSING_AUCTION);
    auctions[(ubfa_asset_contract, ubfa_asset_id)].auction_data.auction_last_bid := some(ubfa_bid);
  }
}

entry update_auction(auction: auction_record) {
  called by require_some(auction_contract, MISSING_AUCTION_CONTRACT)
  require {
      ua_0: issome(auction_contract);
      ua_1: issome(auction.auction_sell_asset.asset_contract);
      ua_2: issome(auction.auction_sell_asset.asset_id)
  }
  effect {
    //TODO: add checks for fields that should not be updated
    auctions.addupdate(
      (
        opt_get(auction.auction_sell_asset.asset_contract),
        opt_get(auction.auction_sell_asset.asset_id)
      ),
      {
        auction_data = auction
      }
    );
  }
}

entry extend_auction_duration(ead_asset_contract: address, ead_asset_id: nat, ead_duration: duration) {
  called by require_some(auction_contract, MISSING_AUCTION_CONTRACT)
  effect {
    dorequire(auctions.contains((ead_asset_contract, ead_asset_id)), MISSING_AUCTION);
    var ead_auction: auction_record = auctions[(ead_asset_contract, ead_asset_id)].auction_data;
    var new_end_time = now + ead_duration;
    auctions[(ead_asset_contract, ead_asset_id)].auction_data.auction_end_time := new_end_time;
  }
}

entry remove_auction(ra_asset : address, ra_asset_id : nat) {
  called by require_some(auction_contract, MISSING_AUCTION_CONTRACT)
  effect {
    auctions.remove((ra_asset, ra_asset_id));
  }
}

view auction_exists(ae_asset : address, ae_asset_id : nat) : bool {
  return auctions.contains((ae_asset, ae_asset_id))
}

view get_auction(ga_asset : address, ga_asset_id : nat) : auction_record {
  return auctions[(ga_asset, ga_asset_id)].auction_data
}

entry transfer_custody_tez(tct_destination: address, amount: tez) {
  called by require_some(auction_contract, MISSING_AUCTION_CONTRACT)
  effect {
    transfer amount to tct_destination;
  }
}