archetype auction_storage(
  owner: address
)
with metadata ""

constant MISSING_AUCTION_CONTRACT: string = "MISSING_AUCTION_CONTRACT"
constant MISSING_ASSET_ID: string = "MISSING_ASSET_ID"
constant MISSING_ASSET_CONTRACT: string = "MISSING_ASSET_CONTRACT"
constant MISSING_AUCTION: string = "MISSING_AUCTION"

enum fa2_class =
| Fungible
| NonFungible
| Unknown

enum enum_asset_class =
| XTZ
| FA_1_2
| FA_2<fa2_class>
| FA_2_LAZY<fa2_class>
| OTHER<bytes>

record rec_asset_type {
  asset_class : enum_asset_class;
}

record %asset {
  asset_type : rec_asset_type;
  asset_contract : option<address>;
  asset_id: option<nat>;
}

record part {
  part_account : address;
  part_value   : nat;
}

record operator_param {
  opp_owner    : address;
  opp_operator : address;
  opp_token_id : nat
} as ((owner, (operator, token_id)))

//----------------------------------------------------------------------------
// Owner role transfer
//----------------------------------------------------------------------------

variable owner_candidate : option<address> = none

entry declare_ownership(candidate : address) {
  called by owner
  effect {
    owner_candidate := some(candidate);
  }
}

entry claim_ownership() {
  called by opt_get(owner_candidate)
  effect {
    owner := opt_get(owner_candidate);
    owner_candidate := none
  }
}

//----------------------------------------------------------------------------
// Admin
//----------------------------------------------------------------------------
entry set_auction_contract(sac_contract : address) {
  called by owner
  effect {
    auction_contract := some(sac_contract);
  }
}

//----------------------------------------------------------------------------
// Auction
//----------------------------------------------------------------------------
variable auction_contract : option<address> = none
variable max_transferrable_fa12_amount : nat = 10000000000000000000

record bid {
  bid_payouts : list<part>;
  bid_origin_fees : list<part>;
  bid_amount : nat;
  bid_bidder: address;
}

record auction_record {
  auction_sell_asset : %asset;
  auction_sell_asset_amount: nat;
  auction_buy_asset : %asset;
  auction_last_bid: option<bid>;
  auction_seller: address;
  auction_start_time: date;
  auction_end_time: date;
  auction_minimal_price: nat;
  auction_buy_out_price: nat;
  auction_minimal_step: nat;
  auction_protocol_fee: nat;
  auction_payouts : list<part>;
  auction_origin_fees : list<part>;
}

asset auctions identified by auction_asset auction_asset_id to big_map {
  auction_asset : address;
  auction_asset_id: nat;
  auction_data : auction_record;
}

record process_transfer_param {
  ptp_asset_class: enum_asset_class;
  ptp_asset_contract: option<address>;
  ptp_asset_id: option<nat>;
  ptp_amount: nat;
  ptp_origin: address;
  ptp_destination: address;
}

record transfer_param {
  destination_address: address;
  token_id: nat;
  token_amount: nat
} as ((%to, (token_id, amount)))

entry set_auction(sa_auction : auction_record) {
  called by require_some(auction_contract, MISSING_AUCTION_CONTRACT)
  require {
      r0: issome(auction_contract);
      r1: issome(sa_auction.auction_sell_asset.asset_contract);
      r2: issome(sa_auction.auction_sell_asset.asset_id)
  }
  effect {
    var sa_auction_contract = opt_get(auction_contract);
    var sa_asset_id = opt_get(sa_auction.auction_sell_asset.asset_id);
    var sa_asset_contract = opt_get(sa_auction.auction_sell_asset.asset_contract);
    var sa_buy_asset = sa_auction.auction_buy_asset;

    auctions.add({auction_asset = sa_asset_contract; auction_asset_id = sa_asset_id; auction_data = sa_auction});
  }
}

entry update_bid_for_auction(ubfa_asset_contract: address, ubfa_asset_id: nat, ubfa_bid: bid) {
  called by require_some(auction_contract, MISSING_AUCTION_CONTRACT)
  effect {
    dorequire(auctions.contains((ubfa_asset_contract, ubfa_asset_id)), MISSING_AUCTION);
    auctions[(ubfa_asset_contract, ubfa_asset_id)].auction_data.auction_last_bid := some(ubfa_bid);
  }
}

entry update_auction(auction: auction_record) {
  called by require_some(auction_contract, MISSING_AUCTION_CONTRACT)
  require {
      ua_0: issome(auction_contract);
      ua_1: issome(auction.auction_sell_asset.asset_contract);
      ua_2: issome(auction.auction_sell_asset.asset_id)
  }
  effect {
    //TODO: add checks for fields that should not be updated
    auctions.addupdate(
      (
        opt_get(auction.auction_sell_asset.asset_contract),
        opt_get(auction.auction_sell_asset.asset_id)
      ),
      {
        auction_data = auction
      }
    );
  }
}

entry extend_auction_duration(ead_asset_contract: address, ead_asset_id: nat, ead_duration: duration) {
  called by require_some(auction_contract, MISSING_AUCTION_CONTRACT)
  effect {
    dorequire(auctions.contains((ead_asset_contract, ead_asset_id)), MISSING_AUCTION);
    var ead_auction: auction_record = auctions[(ead_asset_contract, ead_asset_id)].auction_data;
    var new_end_time = now + ead_duration;
    auctions[(ead_asset_contract, ead_asset_id)].auction_data.auction_end_time := new_end_time;
  }
}

entry remove_auction(ra_asset : address, ra_asset_id : nat) {
  called by require_some(auction_contract, MISSING_AUCTION_CONTRACT)
  effect {
    auctions.remove((ra_asset, ra_asset_id));
  }
}

view auction_exists(ae_asset : address, ae_asset_id : nat) : bool {
  return auctions.contains((ae_asset, ae_asset_id))
}

view get_auction(ga_asset : address, ga_asset_id : nat) : auction_record {
  return auctions[(ga_asset, ga_asset_id)].auction_data
}

entry process_transfer(pt_transfer: process_transfer_param){
  called by require_some(auction_contract, MISSING_AUCTION_CONTRACT)
  effect {
    match pt_transfer.ptp_asset_class with
    | FA_2(fa2t)  -> (
      dorequire(issome(pt_transfer.ptp_asset_contract), MISSING_ASSET_CONTRACT);
      dorequire(issome(pt_transfer.ptp_asset_id), MISSING_ASSET_CONTRACT);

      transfer 0tz to opt_get(pt_transfer.ptp_asset_contract) call %transfer<list<address * list<transfer_param>>>(
            [
                (
                    pt_transfer.ptp_origin,
                    [
                        {
                            destination_address = pt_transfer.ptp_destination;
                            token_id = opt_get(pt_transfer.ptp_asset_id);
                            token_amount = pt_transfer.ptp_amount
                        }
                    ]
                )
            ]
        )
    )
    | FA_1_2 -> (
      dorequire(issome(pt_transfer.ptp_asset_contract), MISSING_ASSET_CONTRACT);
      transfer 0tz to opt_get(pt_transfer.ptp_asset_contract) call %transfer<address * address * nat>((pt_transfer.ptp_origin, pt_transfer.ptp_destination, pt_transfer.ptp_amount))
      )
    | XTZ -> (
        transfer (pt_transfer.ptp_amount*1utz) to pt_transfer.ptp_destination;
      )
    | _ -> ()
    end;
  }
}


entry default() {}